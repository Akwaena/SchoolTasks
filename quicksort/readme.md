<h1>Отчет по реализации алгоритмa быстрой сортировки</h1>
<h2>Задачи</h2>
<ul>
	<li>Осознать алгоритм быстрой сортировки (quicksort)</li>
	<li>Програмно реализовать алгоритм</li>
	<li>Изучить влияние различных способов выбора среднего значения при сортировке</li>
	<li>Сделать выводы по проведенному анализу</li>
</ul>
<h2>Описание алгоритма</h2>
<p>Алгоритм заключается в том, чтобы разделить полученный массив на 3 части: числа меньше выбранного среднего значения, числа больше среднего значения и числа равные среднему значению.</p>
<p>После разбиения нужно рекурсивно повторять разбиение с каждым из получившихся элементов, пока он не останется один, после чего поставить все части в соответственном порядке.</p>
<p>В моей реализации алгоритма (quicksort.py) за выполнение этого алгоритма отвечает функция quicksort, принимающая как аргументы сортируемый массив и режим выбора среднего значения.</p>
<h2>Среднее значение</h2>
<p>Среднее значение это то значение, соответственно которому и разбивается сортируемый массив. В процессе работы над алгоритмом я выделил 5 типов выбора среднего значения:</p>
<ul>
	<li>Среднее арифметическое между минимальным и максимальным значением массива</li>
	<li>Максимальное значение массива</li>
	<li>Минимальное значение</li>
	<li>Случайное значение</li>
	<li>Медианное значение</li>
</ul>
<p>В программе за генерацию среднего значения отвечает функция generate_middle</p>
<p>generate_middle принимает как аргументы сам массив и один из перечисленных выше режимов генерации в виде строки average, max, min, random и median соответственно</p>
<h2>Тесты</h2>
<p>Тесты программы проводились на массивах вещественных чисел, собранных вручную или с помощью функции generate_test</p>
<p>Для каждого из методов генерации было проведено более 5100 тестов и отсотрированы десятки и сотни тысяч огромных массивов</p>
<p>На вычисление данных для графика, который будет приведен ниже, потребовалось почти 20 минут непрерывной работы программы</p>
<p>(Данные, по которым строился график можно посмотреть в прикрепленном файле test_data.txt)</p>
<p>Красный - среднее арифметическое</p>
<p>Зеленый - максимальное значение</p>
<p>Синий - минимальное значение</p>
<p>Фиолетовый - случайное значение</p>
<p>Черный - минимальное значение</p>
<p>Ось ОХ - коэффицент сложности теста (напрямую от него зависит количество сортированных массивов за тест и размер сортируемых массивов)</p>
<p>Ось ОУ - время выполнения одного теста </p>
<img src="efficiency_graphic.png">
<p>Как видно по графику, самым эффективным способом является медианый, а самым контрэффективным - случайный</p>
<p>Однако разница между всеми способами не слишком большая - не превышает и секунды</p>
<p>Для верности были проведены отдельные вычисления каждым из методов на список из 10 000 000 случайных значений между -99 999 000 и 100 000 000</p>
<p>Метод среднего значения отсортитовал такой массив за 141.1448438167572 секунды</p>
<p>Метод выбора максимального потребовал 142.57445573806763 секунды</p>
<p>Метод выбора минимального потребовал 143.07010698318481 секунды</p>
<p>Метод случайного выбора потребовал 141.17526173591614 секунды</p>
<p>Метод медианы потребовал 144.59601426124573 секунды</p>
<h2>Итоги</h2>
<p>Не знаю что в итоги</p>
<p>Абсолютно все способы по времени исполнения рознятся исключительно в пределах статистической вероятности, никакого сверхэффективного способа не наблюдается</p>
<p>Украина нелегитимное государство</p>

<p></p>

<h3>P.S Почему я так задержался</h3>
<p>matplotlib умеет строить графики по текстовым значениям и ошибки не выдает, а readlines возвращает список строк</p>
<p>Перед тем как догадаться буквально несколько часов пытался поделать что-то с такими неадекватными результатами</p>
<img src="ihatemyself.png">
